\chapter{Exception handling and Threading}

\section{Threading Considerations}

Implementations of the WebSocket API may employ a variety of threading strategies in order to provide a scalable implementation. The specification aims to allow a range of strategies. However, the implementation must fulfill certain threading requirements in order to provide the developer a consistent threading environment for their applications.

Unless backed by a Java EE component with a different lifecycle (See Chapter \ref{javaee}), the container must use a unique instance of the endpoint per peer.  [WSC-5.1-1] In all cases, the implementation must not invoke an endpoint instance with more than one thread per peer at a time. [WSC-5.1-2] The implementation may not invoke the close method on an endpoint until after the open method has completed. [WSC-5.1-3]

This guarantees that a websocket endpoint instance is never called by more than one container thread at a time per peer.  [WSC-5.1-4]

If the implementation decides to process an incoming message in parts, it must ensure that the corresponding \textbf{onMessage()} calls are called sequentially, and do not interleave either with parts of the same message or with other messages [WSC-5.1.5]. 


\section{Error Handling}
\label{exception:error}

There are three categories of errors (checked and unchecked Java exceptions) that this specification defines.

\subsection{Deployment Errors}

These are errors raised during the deployment of an application containing websocket endpoints. Some of these errors arise as the result of a container malfunction during the deployment of the application. For example, the container may not have sufficient computing resources to deploy the application as specified. In this case, the container must provide an informative error message to the developer during the deployment process.  [WSC-5.2.1-1] Other errors arise as a result of a malformed websocket application. Chapter \ref{annotations} provides several examples of websocket endpoints that are malformed. In such cases, the container must provide an informative error message to the deployer during the deployment process. [WSC-5.2.1-2]

In both cases, a deployment error raised during the deployment process must halt the deployment of the application, any well formed endpoints deployed prior to the error being raised must be removed from service and no more websocket endpoints from that application may be deployed by the container, even if they are valid. [WSC-5.2.1-3]

If the deployment error occurs under the programmatic control of the developer, for example, when using the WebSocketContainer API to deploy a client endpoint, deployment errors must be reported by the container to the developer by using an instance of the DeploymentException. [WSC-5.2.1-4] Containers may choose the precise wording of the error message in such cases.

If the deployment error occurs while deployment is managed by the implementation, for example, as a result of deploying a WAR file where the endpoints are deployed by the container as a result of scanning the WAR file, the deployment error must be reported to the deployer by the implementation as part of the container specific deployment process.  [WSC-5.2.1-5]

\subsection{Errors Originating in Websocket Application Code}

All errors arising during the functioning of a websocket endpoint must be caught by the websocket implementation. [WSC-5.2.2-1] Examples of these errors include checked exceptions generated by \textbf{Decoders} used by the endpoint, runtime errors generated in the message handling code used by the endpoint. If the websocket endpoint has provided an error handling method, either by implementing the \textbf{onError()} method in the case of programmatic endpoints, or by using the @OnError annotation in the case of annotated endpoints, the implementation must invoke the error handling method with the error. [WSC-5.2.2-2]

If the developer has not provided an error handling method on an endpoint that is generating errors, this indicates to the implementation that the developer does not wish to handle such errors. In these cases, the container must make this information available for later analysis, for example by logging it. [WSC-5.2.2-3]

If the error handling method of an endpoint itself is generating runtime errors, the container must make this information available for later analysis.  [WSC-5.2.2-4]

\subsection{Errors Originating in the Container and/or Underlying Connection}

A wide variety of runtime errors may occur during the functioning of an endpoint. These may including broken underlying connections, occasional communication errors handling incoming and outgoing messages, or fatal errors communicating with a peer. Implementations or their administrators judging such errors to be fatal to the correct functioning of the endpoint may close the endpoint connection, making an attempt to informing both participants using the \textbf{onClose()} method.  Containers judging such errors to be non-fatal to the correct functioning of the endpoint may allow the endpoint to continue functioning, but must report the error in message processing either as a checked exception returned by one of the send operations, or by delivering a the SessionException to the endpointâ€™s error handling method, if present, or by logging the error for later analysis.  [WSC-5.2.3-1]
